% Author @ Huyen Tran, DONE

\subsection{Edmonds-Karp Implementation} \label{ekImplement}

In this implementation, the \texttt{MaxMatchingBipartite} class inherits from an abstract \texttt{Solver} class to compute the maximum matching in a bipartite graph using the \textbf{Edmonds-Karp algorithm}, introduced in section \ref{ek algo}. This approach utilizes a breadth-first search (BFS) to find augmenting paths in a flow network representation of the bipartite graph. Key elements and methods include:

\paragraph{Initialization}: The program begins by initializing the graph representation and setting up the residual graph. The \texttt{solve()} function accepts a graph instance \( G = (d, n, m, E) \). The residual graph is initialized as a nested dictionary, where capacities are assigned as follows: the source node is connected to each left vertex (set \( U \)) with unit capacity, the sink node is connected to each right vertex (set \( V \)) with unit capacity, and edges between sets \( U \) and \( V \) are assigned unit capacities based on the edges in \( E \).

\paragraph{Edmonds-Karp Algorithm Execution:} The algorithm is implemented by iteratively finding augmenting paths in the residual graph and adjusting capacities until no augmenting paths remain. Each iteration begins with a breadth-first search (BFS) from the source node to the sink node. The BFS explores the graph layer by layer, ensuring that the shortest path in terms of edge count is identified whenever an augmenting path exists. If an augmenting path is discovered, the program calculates the minimum residual capacity along this path, which determines the flow that can be pushed through. The \texttt{augment\_path()} function updates the residual graph by reducing capacities along forward edges and increasing capacities along reverse edges for this flow. These updates maintain the integrity of the flow network and prepare the graph for the next iteration. The process repeats until BFS fails to find an augmenting path, at which point the residual graph represents the final maximum flow.

\paragraph{Finding Augmenting Paths (BFS):} The process of finding augmenting paths in the residual graph is performed by the \texttt{BFS()} function, which uses breadth-first search to identify paths from the source to the sink that have positive residual capacity. This search begins by initializing the source node, marking it as visited, and adding it to a queue. The function maintains two dictionaries: one to record the distance of each node from the source, and another to track the previous vertex along the path. As BFS progresses, it explores adjacent vertices of the current node, checking whether the residual capacity of each edge is greater than zero and whether the adjacent vertex has not yet been visited. If these conditions are satisfied, the adjacent vertex is marked as visited, its distance from the source is updated, and its previous vertex is set to the current node. This vertex is then enqueued for further exploration. When the sink node is reached, the BFS halts and returns \texttt{True}, indicating the presence of an augmenting path. If the BFS completes without reaching the sink, the function returns \texttt{False}, signaling that no further augmenting paths exist. 

\paragraph{Flow Augmentation}: The flow augmentation process is carried out by the \texttt{augment\_path()} function, which updates the residual graph along the augmenting path found by the \texttt{BFS()} function. This process begins by identifying the minimum residual capacity along the augmenting path, which represents the maximum flow that can be pushed through this path without exceeding the capacities of any edge. To determine this minimum capacity, the function traces the path backward from the sink to the source using the dictionary of previous vertices populated during BFS. At each step, the residual capacity of the edge is compared to the current minimum flow, and the smallest value is retained. \\
Once the minimum capacity is identified, the function updates the residual graph by decreasing the capacities along the forward edges of the path by this flow value and increasing the capacities along the reverse edges by the same value. These updates ensure that the residual graph reflects the adjusted flow network, where the forward edges represent the remaining available capacity and the reverse edges allow for the possibility of reducing flow in subsequent iterations if necessary. The flow value for this augmenting path is added to the total flow of the graph, incrementally building towards the maximum flow. This iterative augmentation continues until no further augmenting paths can be found. 

\paragraph{Extracting the Matching}
After completing the flow augmentation process, the maximum matching is extracted from the residual graph. This step involves examining the edges in the bipartite graph to identify pairs of vertices that form the matching. The program iterates through the residual capacity of each reverse edge (from \( V \) to \( U \)) in the residual graph. A positive residual capacity on this reverse edge indicates that the edge was part of the flow in the original graph, signifying a matched pair. This matching is returned as a tuple of $n$-edges representing the maximum matching.\\

\noindent By using BFS to find shortest augmenting paths, the algorithm efficiently finds maximum matching in polynomial time. The separation of \texttt{BFS()} and \texttt{augment\_path()} functions simplifies the flow augmentation process, while the nested dictionary structure allows flexible updates of residual capacities.




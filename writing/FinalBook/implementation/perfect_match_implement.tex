% @author Huyen Tran, DONE
\subsection{Perfect Matching via Gaussian Elimination Implementation} \label{pmReduction}

In this implementation, the \texttt{PMBipartite} class inherits from an abstract \texttt{Solver} class to compute the perfect matching in a bipartite graph using the \textbf{Simple-Bipartite-Matching algorithm}, introduced in section \ref{matrix-perfect-matching}. This approach uses a matrix-based reduction to iteratively identify and refine matchings by using the ske-symmetric adjacency matrix to represent the graph's edges. The algorithm combines matrix inversion with the Schur complement to update the adjacency matrix efficiently. 

\paragraph{Matrix Construction:}
The \texttt{graph\_to\_adj} function takes the input graph \( G = (d, n, m, E) \) and generates a skew-symmetric adjacency matrix \( \tilde{A}(G) \), where \( \tilde{A}(G) \) has the block format:
\[
\tilde{A}(G) =
\begin{bmatrix}
0 & A_{12} \\
-A_{12}^T & 0
\end{bmatrix}.
\]
Since we only consider bipartite graphs, any non-zero entry \( A_{ij} \neq 0 \) in \( A_{12} \) or \( -A_{12}^T \) represents the same edge. For efficient implementation, the program directly constructs \( A = A_{12} \), assigning random weights \( x_{ij} \) for edges \( (i, j) \in E \). Specifically, \( A_{ij} = x_{ij} \) for \( i < j \) and \( A_{ij} = -x_{ij} \) for \( i > j \). Random weights are chosen uniquely from a sufficiently large range to minimize collisions and ensure stability during matrix inversion.

\paragraph{Matrix-Based Matching:}
After constructing the adjacency matrix \( A \), the inverse \( B = A^{-1} \) is computed. Non-zero entries in \( B \) indicate potential matching edges. The program iterates through each column \( c \) to identify an allowed edge. It examines the \( c \)-th column of \( B \) for a row \( r \) such that \( B[r, c] \neq 0 \) and  \( A[c, r] \neq 0 \) to ensure that we only consider edge exists in the original graph \( G \). Then, the edge \( (v, u) = (c, r) \) is added to the matching set \( M \), and the program proceeds to update the matrix \( B \).

\paragraph{Matrix Update Using the Schur Complement:}
When a valid edge \( (v, u) \) is selected, the matrix \( B \) is updated using the Schur complement to reduce the influence of the matched edge. The update formula is:
\[
B' = B - \frac{\mathbf{u} \mathbf{v}^T}{B[v, u]},
\]
where \( \mathbf{u} \) is the column vector corresponding to \( u \), and \( \mathbf{v} \) is the row vector corresponding to \( v \). After applying the Schur complement, the \( v \)-th row and \( u \)-th column are cleared by setting them to zero, effectively removing the matched vertices from further consideration.

\paragraph{Matching Extraction:}
The iterative process continues until all vertices are matched (\( |M| = n \)) or no valid edges remain in \( B \). The final matching \( M \) is extracted as a set of edges covering all vertices in the bipartite graph. If the algorithm does not find a perfect matching within the given number of iterations, it terminates without a result.

\paragraph{Randomized Approach and Repeated Attempts:}
Because random weights are used to construct \( A \), the performance of the algorithm can vary across runs. To address this variability, the implementation includes a retry mechanism that runs the algorithm multiple times (up to a maximum number of attempts or a time limit) until a perfect matching is found. This approach increases the likelihood of success while maintaining overall efficiency.\\

\noindent The use of skew-symmetric matrices and random weights ensures that the algorithm can efficiently handle dense bipartite graphs. By iteratively refining \( B \) using the Schur complement, the algorithm avoids traversing graph edges directly and instead leverages fast matrix operations. The complexity is \( O(n^\omega) \), where \( \omega \) is the matrix multiplication exponent, making the method computationally efficient for large-scale problems. The use of random weights in \( A \) introduces variability in performance, as the success of the algorithm depends on \( A \) being invertible. Dense bipartite graphs improve the likelihood of obtaining an invertible matrix, as the larger number of edges leads to a more populated \( A \), reducing the chances of linear dependence among rows or columns. This makes the algorithm particularly effective for dense graphs, where it performs better both in terms of runtime and consistency.




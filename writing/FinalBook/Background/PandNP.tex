\textbf{ Polynomial Time}, also known as P, refers to the class of decision problems that can be solved efficiently by a deterministic algorithm in polynomial time. A problem is in P if there exists an algorithm that can find a solution in a time complexity that is at most a polynomial function of the size of the input\cite{cormen2009}. In practical terms, this means that as the input size grows, the time required to solve the problem increases at a manageable rate, which allows for efficient computation.

Examples of problems in P include common computational tasks such as sorting a list of numbers (using algorithms like quicksort or mergesort) or finding the shortest path in a graph (such as with Dijkstra's algorithm). Because algorithms for these problems can process larger datasets efficiently, P problems are foundational to computational tasks across various fields, including computer science, operations research, and many practical applications.

\textbf{Nondeterministic Polynomial Time (NP)} is a class of decision problems for which, given a candidate solution, it is possible to verify whether the solution is correct in polynomial time using a deterministic algorithm. This characteristic makes NP a central concept in computational complexity theory. Problems in NP are of immense practical importance and appear across diverse fields such as cryptography, where security often depends on the difficulty of certain NP problems, optimization, where solutions must be both feasible and optimal, and artificial intelligence, particularly in areas such as machine learning and planning. The study of NP problems helps researchers understand the limits of efficient computation and explore the boundaries between problems that can be easily solved and those that can only be verified efficiently.

One of the key insights about NP is that while finding a solution can be hard, verifying that a given solution is correct is computationally feasible \cite{cook2000p}. For example, if you are given a solution to a sudoku puzzle, verifying that it follows the puzzleâ€™s rules can be done quickly, but finding the solution itself may take considerably more time.

\subsubsection*{NP-Complete and NP-Hard}

Within NP, a special subset of problems known as \textbf{NP-complete problems} are of particular importance. These problems are both in NP and as hard as any problem in NP. 
\begin{theorem}
If a polynomial-time algorithm were discovered for any NP-complete problem, then every problem in NP could be solved efficiently, implying \( P = NP \). \cite{fortnow2009status}.
\end{theorem}
NP-complete problems are critical because they capture the essence of difficult computational challenges: any problem in NP can be reduced to an NP-complete problem in polynomial time. Examples of NP-complete problems include the satisfiability (SAT) problem, the traveling salesman problem, the vertex cover problem, and perfect matching for \(d \geq 3\) \cite{hromkovic2020attacking}.

\textbf{NP-hard problems}, on the other hand, are at least as hard as the hardest problems in NP, but they are not required to be in NP. These problems may not have a solution that can be verified in polynomial time \cite{sipser1992history}. For instance, while the decision version of the traveling salesman problem is NP-complete, the optimization version (which asks for the shortest route) is NP-hard \cite{fortnow2009status}. NP-hard problems illustrate the significant complexity involved in computational tasks, often requiring far more computational resources than problems in NP. Examples of problems that are NP-hard but are not believed to be NP-complete include the Halting Problem, which is undecidable and not in NP, and the Post Correspondence Problem, which is known to be NP-hard but not NP-complete, as it does not have a polynomial-time verification process. Another such problem is the Graph Isomorphism Problem, which is NP-hard, but is not known to be NP-complete because no polynomial-time verification process has been discovered, and it is also not proven to be solvable in polynomial time. These problems further underscore the complexity of computational challenges and their significance in theoretical computer science.

The classification of problems as NP, NP-complete, or NP-hard is central to computational complexity theory, influencing fields like logistics, network design, and operations research. However, solving these problems efficiently remains a challenge unless \( P = NP \), a question still unresolved in theoretical computer science \cite{cook2000p}.




